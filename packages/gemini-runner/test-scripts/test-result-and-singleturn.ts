#!/usr/bin/env bun

/**
 * Integration Test: Result Message Coercion & Single-Turn Mode
 *
 * This test verifies two critical GeminiRunner features:
 * 1. Result messages include actual final assistant response content (not generic "Session completed successfully")
 * 2. Single-turn mode works correctly with -shortone model aliases
 *
 * Prerequisites:
 * - GEMINI_API_KEY environment variable must be set
 * - gemini CLI installed: npm install -g @google/gemini-cli@0.17.0
 * - ~/.gemini/settings.json should have -shortone aliases (auto-generated by GeminiRunner)
 *
 * Usage:
 *   cd packages/gemini-runner
 *   bun test-scripts/test-result-and-singleturn.ts
 */

import { existsSync, mkdirSync } from "node:fs";
import { homedir } from "node:os";
import { join } from "node:path";
import type { SDKMessage, SDKResultMessage } from "cyrus-core";
import { GeminiRunner } from "../dist/GeminiRunner.js";

// Test configuration
const TEST_CYRUS_HOME = join(homedir(), ".cyrus-test-gemini");
const TEST_WORKING_DIR = process.cwd();

// Color output helpers
const colors = {
	green: (text: string) => `\x1b[32m${text}\x1b[0m`,
	red: (text: string) => `\x1b[31m${text}\x1b[0m`,
	yellow: (text: string) => `\x1b[33m${text}\x1b[0m`,
	cyan: (text: string) => `\x1b[36m${text}\x1b[0m`,
	bold: (text: string) => `\x1b[1m${text}\x1b[0m`,
};

/**
 * Test 1: Verify result message contains actual assistant response content
 */
async function testResultMessageCoercion(): Promise<void> {
	console.log(colors.bold("\nüìù Test 1: Result Message Content Coercion\n"));

	const messages: SDKMessage[] = [];
	let resultMessage: SDKResultMessage | null = null;
	let lastAssistantContent = "";

	const runner = new GeminiRunner({
		cyrusHome: TEST_CYRUS_HOME,
		workingDirectory: TEST_WORKING_DIR,
		model: "gemini-2.5-flash",
		onMessage: (message: SDKMessage) => {
			messages.push(message);
			if (message.type === "assistant") {
				const content = message.message.content;
				if (Array.isArray(content) && content.length > 0) {
					const textBlock = content.find((block) => block.type === "text");
					if (textBlock && "text" in textBlock) {
						lastAssistantContent = textBlock.text;
					}
				}
			}
			if (message.type === "result") {
				resultMessage = message as SDKResultMessage;
			}
		},
	});

	console.log(
		colors.cyan("   Sending prompt: 'Say exactly: RESULT_TEST_SUCCESS'\n"),
	);

	await runner.start("Say exactly: RESULT_TEST_SUCCESS");

	// Wait for completion
	await new Promise((resolve) => setTimeout(resolve, 5000));

	// Verify we got messages
	if (messages.length === 0) {
		throw new Error(colors.red("‚ùå No messages received from GeminiRunner"));
	}

	console.log(colors.yellow(`   Received ${messages.length} messages\n`));

	// Verify we got a result message
	if (!resultMessage) {
		throw new Error(colors.red("‚ùå No result message received"));
	}

	console.log(
		colors.cyan(
			`   Last assistant content: "${lastAssistantContent.substring(0, 50)}..."\n`,
		),
	);
	console.log(
		colors.cyan(
			`   Result message content: "${resultMessage.result.substring(0, 50)}..."\n`,
		),
	);

	// Test: Result should NOT be the generic message
	if (resultMessage.result === "Session completed successfully") {
		throw new Error(
			colors.red(
				'‚ùå Result message still contains generic "Session completed successfully"',
			),
		);
	}

	// Test: Result should contain the actual assistant response
	if (!resultMessage.result.includes("RESULT_TEST_SUCCESS")) {
		throw new Error(
			colors.red(
				`‚ùå Result message does not contain expected content. Got: "${resultMessage.result}"`,
			),
		);
	}

	// Test: Result content should match last assistant message
	if (resultMessage.result !== lastAssistantContent) {
		console.log(
			colors.yellow(
				"   ‚ö†Ô∏è  Result differs from last assistant message (may include extra formatting)",
			),
		);
	}

	console.log(
		colors.green("   ‚úÖ Result message contains actual assistant response\n"),
	);
	console.log(colors.green("   ‚úÖ Result coercion working correctly\n"));
}

/**
 * Test 2: Verify single-turn mode works with -shortone model alias
 */
async function testSingleTurnMode(): Promise<void> {
	console.log(colors.bold("\nüîÑ Test 2: Single-Turn Mode\n"));

	const messages: SDKMessage[] = [];
	let resultMessage: SDKResultMessage | null = null;

	const runner = new GeminiRunner({
		cyrusHome: TEST_CYRUS_HOME,
		workingDirectory: TEST_WORKING_DIR,
		model: "gemini-2.5-flash-shortone", // Using -shortone alias
		maxTurns: 1, // Explicit single-turn
		onMessage: (message: SDKMessage) => {
			messages.push(message);
			if (message.type === "result") {
				resultMessage = message as SDKResultMessage;
			}
		},
	});

	console.log(
		colors.cyan(
			"   Using model: gemini-2.5-flash-shortone (maxSessionTurns: 1)\n",
		),
	);
	console.log(
		colors.cyan("   Sending prompt: 'Count to 3 and say SINGLETURN_TEST'\n"),
	);

	await runner.start("Count to 3 and say SINGLETURN_TEST");

	// Wait for completion
	await new Promise((resolve) => setTimeout(resolve, 5000));

	// Verify we got messages
	if (messages.length === 0) {
		throw new Error(colors.red("‚ùå No messages received from GeminiRunner"));
	}

	console.log(colors.yellow(`   Received ${messages.length} messages\n`));

	// Verify we got a result message
	if (!resultMessage) {
		throw new Error(colors.red("‚ùå No result message received"));
	}

	// Test: Should complete successfully in single turn
	if (resultMessage.subtype !== "success") {
		throw new Error(
			colors.red(`‚ùå Expected success, got: ${resultMessage.subtype}`),
		);
	}

	// Test: num_turns should be 0 or 1 (no multi-turn conversation)
	if (resultMessage.num_turns > 1) {
		throw new Error(
			colors.red(
				`‚ùå Expected single turn (0-1), got ${resultMessage.num_turns} turns`,
			),
		);
	}

	console.log(
		colors.green(`   ‚úÖ Completed in ${resultMessage.num_turns} turn(s)\n`),
	);
	console.log(colors.green("   ‚úÖ Single-turn mode working correctly\n"));
}

/**
 * Test 3: Verify settings.json auto-generation
 */
async function testSettingsGeneration(): Promise<void> {
	console.log(colors.bold("\n‚öôÔ∏è  Test 3: Settings.json Auto-Generation\n"));

	const settingsPath = join(homedir(), ".gemini", "settings.json");

	console.log(
		colors.cyan(`   Checking for settings.json at: ${settingsPath}\n`),
	);

	if (!existsSync(settingsPath)) {
		console.log(
			colors.yellow(
				"   ‚ÑπÔ∏è  settings.json doesn't exist yet, will be created on first GeminiRunner spawn\n",
			),
		);
	} else {
		console.log(colors.green("   ‚úÖ settings.json exists\n"));

		// Read and verify it has -shortone aliases
		const settings = await Bun.file(settingsPath).json();

		if (!settings.modelConfigs?.aliases) {
			throw new Error(
				colors.red("‚ùå settings.json missing modelConfigs.aliases"),
			);
		}

		const aliases = settings.modelConfigs.aliases;
		const expectedAliases = [
			"gemini-3-pro-preview-shortone",
			"gemini-2.5-pro-shortone",
			"gemini-2.5-flash-shortone",
			"gemini-2.5-flash-lite-shortone",
		];

		for (const alias of expectedAliases) {
			if (!aliases[alias]) {
				throw new Error(colors.red(`‚ùå Missing alias: ${alias}`));
			}
			if (aliases[alias].maxSessionTurns !== 1) {
				throw new Error(
					colors.red(`‚ùå ${alias} should have maxSessionTurns: 1`),
				);
			}
		}

		console.log(colors.green("   ‚úÖ All -shortone aliases present\n"));
		console.log(colors.green("   ‚úÖ All aliases have maxSessionTurns: 1\n"));
	}
}

/**
 * Main test runner
 */
async function runTests(): Promise<void> {
	console.log(colors.bold("\nüß™ GeminiRunner Integration Tests\n"));
	console.log(colors.bold("==================================\n"));

	// Check prerequisites
	if (!process.env.GEMINI_API_KEY) {
		console.error(
			colors.red("\n‚ùå GEMINI_API_KEY environment variable not set\n"),
		);
		console.error(
			colors.yellow("   Set it with: export GEMINI_API_KEY='your-api-key'\n"),
		);
		process.exit(1);
	}

	// Create test cyrus home if it doesn't exist
	if (!existsSync(TEST_CYRUS_HOME)) {
		mkdirSync(TEST_CYRUS_HOME, { recursive: true });
	}

	try {
		// Run tests sequentially
		await testResultMessageCoercion();
		await testSingleTurnMode();
		await testSettingsGeneration();

		console.log(colors.bold("\n‚úÖ All Tests Passed!\n"));
		console.log(colors.green("==================================\n"));
	} catch (error) {
		console.error(colors.bold("\n‚ùå Tests Failed\n"));
		console.error(colors.red("==================================\n"));
		console.error(error);
		process.exit(1);
	}
}

// Run tests
runTests();
