/**
 * Agent Runner Interface
 *
 * Abstract interface for running AI agents (Claude, Cursor, etc.)
 * This interface decouples the core orchestration logic from specific agent implementations.
 */

/**
 * Configuration for starting a new agent session
 */
export interface AgentSessionConfig {
	/**
	 * Working directory where the agent will operate
	 */
	workingDirectory: string;

	/**
	 * Initial prompt or stream of messages to send to the agent
	 * Can be a single string or an async iterable for streaming prompts
	 */
	prompt: string | AsyncIterable<UserMessage>;

	/**
	 * Optional system prompt to configure agent behavior
	 */
	systemPrompt?: string;

	/**
	 * List of tools that the agent is allowed to use
	 * If not specified, agent can use all available tools
	 */
	allowedTools?: string[];

	/**
	 * List of tools that the agent is NOT allowed to use
	 * Takes precedence over allowedTools if both are specified
	 */
	disallowedTools?: string[];

	/**
	 * Environment variables to pass to the agent process
	 */
	environment?: Record<string, string>;

	/**
	 * Maximum number of turns (interactions) the agent can take
	 * Used to prevent runaway sessions
	 */
	maxTurns?: number;

	/**
	 * AI model to use for the agent (e.g., "claude-3-opus", "gpt-4")
	 */
	model?: string;
}

/**
 * Represents a user message that can be sent to an agent
 */
export interface UserMessage {
	/**
	 * Message content (text)
	 */
	content: string;

	/**
	 * Optional attachments (files, images, etc.)
	 */
	attachments?: Attachment[];

	/**
	 * Message timestamp
	 */
	timestamp?: Date;
}

/**
 * Represents a file or other attachment
 */
export interface Attachment {
	/**
	 * File name
	 */
	name: string;

	/**
	 * File path or URL
	 */
	path: string;

	/**
	 * MIME type (e.g., "image/png", "text/plain")
	 */
	mimeType?: string;

	/**
	 * File size in bytes
	 */
	size?: number;
}

/**
 * Represents an active agent session
 */
export interface AgentSession {
	/**
	 * Unique identifier for this session
	 */
	id: string;

	/**
	 * When the session started
	 */
	startedAt: Date;

	/**
	 * Stream of events from the agent
	 * Consumers should iterate over this to receive real-time updates
	 */
	events: AsyncIterable<AgentEvent>;
}

/**
 * Summary information when a session completes
 */
export interface SessionSummary {
	/**
	 * Total number of turns taken
	 */
	turns: number;

	/**
	 * Total number of tools used
	 */
	toolsUsed: number;

	/**
	 * List of files modified during the session
	 */
	filesModified: string[];

	/**
	 * Agent's final summary or conclusion
	 */
	summary?: string;

	/**
	 * Exit status (0 = success, non-zero = error)
	 */
	exitCode: number;
}

/**
 * Events that can be emitted by an agent during execution
 * Uses discriminated union for type safety
 */
export type AgentEvent =
	| TextEvent
	| ToolUseEvent
	| ToolResultEvent
	| ErrorEvent
	| CompleteEvent;

/**
 * Agent generated text output
 */
export interface TextEvent {
	type: "text";
	/**
	 * Text content generated by the agent
	 */
	content: string;
}

/**
 * Agent is using a tool
 */
export interface ToolUseEvent {
	type: "tool-use";
	/**
	 * Name of the tool being used
	 */
	tool: string;
	/**
	 * Input parameters passed to the tool
	 */
	input: unknown;
}

/**
 * Result from a tool execution
 */
export interface ToolResultEvent {
	type: "tool-result";
	/**
	 * Name of the tool that was executed
	 */
	tool: string;
	/**
	 * Output from the tool execution
	 */
	output: unknown;
	/**
	 * Whether the tool execution was successful
	 */
	success: boolean;
}

/**
 * An error occurred during agent execution
 */
export interface ErrorEvent {
	type: "error";
	/**
	 * Error that occurred
	 */
	error: Error;
}

/**
 * Agent session has completed
 */
export interface CompleteEvent {
	type: "complete";
	/**
	 * Summary of the completed session
	 */
	summary: SessionSummary;
}

/**
 * Abstract interface for running AI agents
 *
 * Implementations of this interface handle the details of spawning, managing,
 * and communicating with specific agent processes (Claude, Cursor, etc.)
 */
export interface AgentRunner {
	/**
	 * Start a new agent session
	 *
	 * @param config - Configuration for the agent session
	 * @returns Promise that resolves to the active session
	 * @throws Error if session cannot be started
	 */
	start(config: AgentSessionConfig): Promise<AgentSession>;

	/**
	 * Send a message to a running session
	 *
	 * @param sessionId - ID of the session to send to
	 * @param message - Message to send
	 * @throws Error if session is not running or message cannot be sent
	 */
	sendMessage(sessionId: string, message: string): Promise<void>;

	/**
	 * Stop a running session
	 *
	 * @param sessionId - ID of the session to stop
	 * @throws Error if session is not running or cannot be stopped
	 */
	stop(sessionId: string): Promise<void>;

	/**
	 * Resume an existing session with new configuration or prompt
	 *
	 * @param sessionId - ID of the session to resume
	 * @param config - Configuration for resuming
	 * @returns Promise that resolves to the resumed session
	 * @throws Error if session cannot be resumed
	 */
	resume(sessionId: string, config: AgentSessionConfig): Promise<AgentSession>;

	/**
	 * Check if a session is currently running
	 *
	 * @param sessionId - ID of the session to check
	 * @returns true if session is running, false otherwise
	 */
	isRunning(sessionId: string): boolean;

	/**
	 * Get the event stream for a running session
	 *
	 * @param sessionId - ID of the session
	 * @returns Async iterable of events
	 * @throws Error if session does not exist
	 */
	getEventStream(sessionId: string): AsyncIterable<AgentEvent>;
}
