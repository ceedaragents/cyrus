/**
 * OrchestrationMessageBus - Handles communication between parent and child agent sessions
 * 
 * This service manages:
 * - Triggering child agent sessions from parent orchestrator
 * - Posting child results back to parent sessions
 * - Managing cross-session communication using Linear's API
 */

import { LinearClient } from '@linear/sdk';

export type MessageType = 'trigger' | 'prompt' | 'result' | 'status' | 'error';

export interface OrchestrationMessage {
  /** Type of message */
  type: MessageType;
  /** Source agent session ID */
  sourceSessionId: string;
  /** Target agent session ID (if known) */
  targetSessionId?: string;
  /** Source issue identifier */
  sourceIssueId: string;
  /** Target issue identifier */
  targetIssueId?: string;
  /** Message content */
  content: string;
  /** Additional metadata */
  metadata?: Record<string, any>;
  /** Timestamp */
  timestamp: Date;
}

export interface MessageBusConfig {
  /** Linear client for API calls */
  linearClient: LinearClient;
  /** Special user auth token for cross-posting */
  userAuthToken?: string;
  /** Agent user ID in Linear */
  agentUserId: string;
}

export class OrchestrationMessageBus {
  private messageQueue: OrchestrationMessage[] = [];
  private messageHandlers: Map<string, Set<(msg: OrchestrationMessage) => Promise<void>>> = new Map();
  
  constructor(private config: MessageBusConfig) {}

  /**
   * Send a message from parent to child
   */
  async sendToChild(
    parentSessionId: string,
    parentIssueId: string,
    childIssueId: string,
    message: string,
    type: MessageType = 'trigger',
  ): Promise<void> {
    const msg: OrchestrationMessage = {
      type,
      sourceSessionId: parentSessionId,
      sourceIssueId: parentIssueId,
      targetIssueId: childIssueId,
      content: message,
      timestamp: new Date(),
    };
    
    this.messageQueue.push(msg);
    console.log(`[MessageBus] Queued message from parent ${parentIssueId} to child ${childIssueId}`);
    
    // Process the message
    await this.processMessage(msg);
  }

  /**
   * Send a result from child back to parent
   */
  async sendToParent(
    childSessionId: string,
    childIssueId: string,
    parentSessionId: string,
    parentIssueId: string,
    result: string,
    success: boolean = true,
  ): Promise<void> {
    const msg: OrchestrationMessage = {
      type: success ? 'result' : 'error',
      sourceSessionId: childSessionId,
      sourceIssueId: childIssueId,
      targetSessionId: parentSessionId,
      targetIssueId: parentIssueId,
      content: result,
      metadata: { success },
      timestamp: new Date(),
    };
    
    this.messageQueue.push(msg);
    console.log(`[MessageBus] Queued ${success ? 'result' : 'error'} from child ${childIssueId} to parent ${parentIssueId}`);
    
    // Process the message
    await this.processMessage(msg);
  }

  /**
   * Process a message and deliver it to the target
   */
  private async processMessage(msg: OrchestrationMessage): Promise<void> {
    try {
      // Notify local handlers first
      await this.notifyHandlers(msg);
      
      // Then deliver via Linear API
      if (msg.type === 'trigger' && msg.targetIssueId) {
        await this.triggerChildAgentSession(msg);
      } else if ((msg.type === 'result' || msg.type === 'error') && msg.targetSessionId) {
        await this.postResultToParent(msg);
      } else if (msg.type === 'prompt' && msg.targetSessionId) {
        await this.sendPromptToSession(msg);
      }
    } catch (error) {
      console.error(`[MessageBus] Failed to process message:`, error);
    }
  }

  /**
   * Trigger a new agent session on a child issue
   */
  private async triggerChildAgentSession(msg: OrchestrationMessage): Promise<void> {
    try {
      // First, assign the issue to the agent if not already assigned
      const issue = await this.config.linearClient.issue(msg.targetIssueId!);
      const assignee = await issue?.assignee;
      
      if (assignee?.id !== this.config.agentUserId) {
        await this.config.linearClient.updateIssue(msg.targetIssueId!, {
          assigneeId: this.config.agentUserId,
        });
        console.log(`[MessageBus] Assigned agent to child issue ${msg.targetIssueId}`);
      }
      
      // Create a comment to trigger the agent session
      // Include context from the parent
      const commentBody = `## Orchestration Context

This sub-issue has been created as part of orchestrated work from parent issue #${msg.sourceIssueId}.

### Instructions from Orchestrator:
${msg.content}

---
*This message was automatically generated by the orchestration system.*`;

      await this.config.linearClient.createComment({
        issueId: msg.targetIssueId!,
        body: commentBody,
      });
      
      console.log(`[MessageBus] Created trigger comment on child issue ${msg.targetIssueId}`);
      
      // The comment creation should trigger a webhook that starts an agent session
    } catch (error) {
      console.error(`[MessageBus] Failed to trigger child agent session:`, error);
      throw error;
    }
  }

  /**
   * Post a result from child back to parent agent session
   */
  private async postResultToParent(msg: OrchestrationMessage): Promise<void> {
    try {
      const activityType = msg.type === 'result' ? 'prompt' : 'error';
      
      // Format the result message
      const formattedMessage = `## Sub-Issue Result: ${msg.sourceIssueId}

${msg.metadata?.success ? '‚úÖ **Completed Successfully**' : '‚ùå **Failed**'}

### Result:
${msg.content}

### Next Steps:
Evaluating result and determining next orchestration action...

---
*Received from child issue #${msg.sourceIssueId} at ${msg.timestamp.toISOString()}*`;

      // Create an agent activity on the parent session
      // This will trigger the parent orchestrator to continue
      await this.config.linearClient.createAgentActivity({
        agentSessionId: msg.targetSessionId!,
        content: {
          type: activityType as any,
          body: formattedMessage,
        },
      });
      
      console.log(`[MessageBus] Posted ${msg.type} to parent session ${msg.targetSessionId}`);
    } catch (error) {
      console.error(`[MessageBus] Failed to post result to parent:`, error);
      throw error;
    }
  }

  /**
   * Send a prompt to an existing agent session
   */
  private async sendPromptToSession(msg: OrchestrationMessage): Promise<void> {
    try {
      await this.config.linearClient.createAgentActivity({
        agentSessionId: msg.targetSessionId!,
        content: {
          type: 'prompt',
          body: msg.content,
        },
      });
      
      console.log(`[MessageBus] Sent prompt to session ${msg.targetSessionId}`);
    } catch (error) {
      console.error(`[MessageBus] Failed to send prompt:`, error);
      throw error;
    }
  }

  /**
   * Register a handler for messages
   */
  onMessage(sessionId: string, handler: (msg: OrchestrationMessage) => Promise<void>): void {
    if (!this.messageHandlers.has(sessionId)) {
      this.messageHandlers.set(sessionId, new Set());
    }
    this.messageHandlers.get(sessionId)!.add(handler);
  }

  /**
   * Unregister a handler
   */
  offMessage(sessionId: string, handler: (msg: OrchestrationMessage) => Promise<void>): void {
    this.messageHandlers.get(sessionId)?.delete(handler);
  }

  /**
   * Notify registered handlers about a message
   */
  private async notifyHandlers(msg: OrchestrationMessage): Promise<void> {
    // Notify handlers for the target session
    if (msg.targetSessionId) {
      const handlers = this.messageHandlers.get(msg.targetSessionId);
      if (handlers) {
        for (const handler of handlers) {
          try {
            await handler(msg);
          } catch (error) {
            console.error(`[MessageBus] Handler error:`, error);
          }
        }
      }
    }
    
    // Also notify handlers for the source session (for acknowledgments)
    const sourceHandlers = this.messageHandlers.get(msg.sourceSessionId);
    if (sourceHandlers) {
      for (const handler of sourceHandlers) {
        try {
          await handler(msg);
        } catch (error) {
          console.error(`[MessageBus] Handler error:`, error);
        }
      }
    }
  }

  /**
   * Get message history for a session
   */
  getMessageHistory(sessionId: string): OrchestrationMessage[] {
    return this.messageQueue.filter(
      msg => msg.sourceSessionId === sessionId || msg.targetSessionId === sessionId
    );
  }

  /**
   * Clear message history (for cleanup)
   */
  clearHistory(sessionId?: string): void {
    if (sessionId) {
      this.messageQueue = this.messageQueue.filter(
        msg => msg.sourceSessionId !== sessionId && msg.targetSessionId !== sessionId
      );
    } else {
      this.messageQueue = [];
    }
  }

  /**
   * Create a formatted orchestration status message
   */
  static formatStatusMessage(
    completedCount: number,
    inProgressCount: number,
    pendingCount: number,
    failedCount: number,
  ): string {
    return `## üìä Orchestration Status

### Progress Overview
- ‚úÖ Completed: ${completedCount}
- üîÑ In Progress: ${inProgressCount}
- ‚è≥ Pending: ${pendingCount}
- ‚ùå Failed: ${failedCount}

Total Sub-Issues: ${completedCount + inProgressCount + pendingCount + failedCount}
Progress: ${Math.round((completedCount / (completedCount + inProgressCount + pendingCount + failedCount)) * 100)}%`;
  }

  /**
   * Create a formatted instruction message for a sub-issue
   */
  static formatSubIssueInstructions(
    parentIssueId: string,
    subIssueTitle: string,
    requirements: string[],
    dependencies?: string[],
  ): string {
    let message = `## üéØ Sub-Issue Instructions

**Parent Issue:** #${parentIssueId}
**Sub-Issue:** ${subIssueTitle}

### Requirements
${requirements.map(req => `- ${req}`).join('\n')}`;

    if (dependencies && dependencies.length > 0) {
      message += `\n\n### Dependencies
${dependencies.map(dep => `- Depends on: #${dep}`).join('\n')}`;
    }

    message += `\n\n---
*Begin work on this sub-issue following the requirements above.*`;

    return message;
  }
}

export default OrchestrationMessageBus;